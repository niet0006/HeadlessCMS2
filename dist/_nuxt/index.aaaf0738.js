import{k as b,h as _,l as w,m as x,p as g,q as C,u as v,s as D,v as P,x as B,y as M,z as O,A as S,B as A,e as $,c as z,C as E,o as j}from"./entry.06b3d9c7.js";const H=()=>null;function N(...o){var p;const c=typeof o[o.length-1]=="string"?o.pop():void 0;typeof o[0]!="string"&&o.unshift(c);let[t,i,e={}]=o;if(typeof t!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof i!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");e.server=e.server??!0,e.default=e.default??H,e.lazy=e.lazy??!1,e.immediate=e.immediate??!0;const a=b(),d=()=>a.isHydrating?a.payload.data[t]:a.static.data[t],l=()=>d()!==void 0;a._asyncData[t]||(a._asyncData[t]={data:_(d()??((p=e.default)==null?void 0:p.call(e))??null),pending:_(!l()),error:w(a.payload._errors,t)});const s={...a._asyncData[t]};s.refresh=s.execute=(r={})=>{if(a._asyncDataPromises[t]){if(r.dedupe===!1)return a._asyncDataPromises[t];a._asyncDataPromises[t].cancelled=!0}if(r._initial&&l())return d();s.pending.value=!0;const f=new Promise((n,u)=>{try{n(i(a))}catch(k){u(k)}}).then(n=>{if(f.cancelled)return a._asyncDataPromises[t];let u=n;e.transform&&(u=e.transform(n)),e.pick&&(u=R(u,e.pick)),s.data.value=u,s.error.value=null}).catch(n=>{var u;if(f.cancelled)return a._asyncDataPromises[t];s.error.value=n,s.data.value=v(((u=e.default)==null?void 0:u.call(e))??null)}).finally(()=>{f.cancelled||(s.pending.value=!1,a.payload.data[t]=s.data.value,s.error.value&&(a.payload._errors[t]=D(s.error.value)),delete a._asyncDataPromises[t])});return a._asyncDataPromises[t]=f,a._asyncDataPromises[t]};const y=()=>s.refresh({_initial:!0}),h=e.server!==!1&&a.payload.serverRendered;{const r=P();if(r&&!r._nuxtOnBeforeMountCbs){r._nuxtOnBeforeMountCbs=[];const n=r._nuxtOnBeforeMountCbs;r&&(x(()=>{n.forEach(u=>{u()}),n.splice(0,n.length)}),g(()=>n.splice(0,n.length)))}h&&a.isHydrating&&l()?s.pending.value=!1:r&&(a.payload.serverRendered&&a.isHydrating||e.lazy)&&e.immediate?r._nuxtOnBeforeMountCbs.push(y):e.immediate&&y(),e.watch&&C(e.watch,()=>s.refresh());const f=a.hook("app:data:refresh",n=>{if(!n||n.includes(t))return s.refresh()});r&&g(f)}const m=Promise.resolve(a._asyncDataPromises[t]).then(()=>s);return Object.assign(m,s),m}function R(o,c){const t={};for(const i of c)t[i]=o[i];return t}const q=async(o,c={},t={})=>{var s,y,h,m,p,r,f;const i=`${JSON.stringify(c)}${o}`,e=B(`${i}-state`,()=>({})),a=M();O(()=>{e.value&&e.value.id&&S(e.value.id,n=>e.value=n,t)});const{data:d,error:l}=await N(`${i}-asyncdata`,()=>a.get(`cdn/stories/${o}`,c));if((s=l.value)!=null&&s.response&&((y=l.value)==null?void 0:y.response.status)>=400&&((h=l.value)==null?void 0:h.response.status)<600)throw D({statusCode:(m=l.value)==null?void 0:m.response.status,statusMessage:((r=(p=l.value)==null?void 0:p.message)==null?void 0:r.message)||"Something went wrong when fetching from storyblok."});return e.value=(f=d.value)==null?void 0:f.data.story,e},K={__name:"index",async setup(o){let c,t;const i=([c,t]=A(()=>q("home",{version:"draft"},{customParent:"http://localhost:3000/"})),c=await c,t(),c);return(e,a)=>{const d=$("StoryblokComponent");return v(i)?(j(),z(d,{key:0,blok:v(i).content},null,8,["blok"])):E("",!0)}}};export{K as default};
